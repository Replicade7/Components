local game = game
local Vector2new = Vector2.new
local Drawingnew = Drawing.new
local Color3fromRGB = Color3.fromRGB
local mathfloor, mathabs, mathclamp = math.floor, math.abs, math.clamp
local wait, spawn = task.wait, task.spawn
local getgenv, cloneref = getgenv, cloneref or function(v) return v end

local GameMetatable = getrawmetatable and getrawmetatable(game) or {}
local __index = GameMetatable.__index or function(self, idx) return self[idx] end
local __newindex = GameMetatable.__newindex or function(self, idx, val) self[idx] = val end
local setrenderproperty = setrenderproperty or __newindex

local Workspace = cloneref(game:GetService("Workspace"))
local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))

local CurrentCamera = __index(Workspace, "CurrentCamera")
local LocalPlayer = __index(Players, "LocalPlayer")

local WorldToViewportPoint = function(...) return CurrentCamera.WorldToViewportPoint(CurrentCamera, ...) end
local GetPlayers = function() return Players:GetPlayers() end
local GetPlayerFromCharacter = function(...) return Players:GetPlayerFromCharacter(...) end
local IsDescendantOf = function(self, parent) return self:IsDescendantOf(parent) end

getgenv().SimpleESP = {
    Settings = {
        Enabled = false,
        TeamCheck = false,
        TeamBasedColors = false,
        TeamColor = Color3fromRGB(170, 170, 255),
        EnemyColor = Color3fromRGB(255, 255, 255),
        AliveCheck = true
    },
    Box = {
        Enabled = false,
        Color = Color3fromRGB(255, 255, 255),
        Transparency = 1,
        Thickness = 1,
        OutlineColor = Color3fromRGB(0, 0, 0),
        Outline = true,
        FillEnabled = true,
        FillTransparency = 0.5
    },
    HealthBar = {
        Enabled = false,
        Offset = 4,
        Blue = 100,
        Thickness = 1,
        Transparency = 1,
        OutlineColor = Color3fromRGB(0, 0, 0),
        Outline = true
    },
    Tracer = {
        Enabled = false,
        Color = Color3fromRGB(255, 255, 255),
        Thickness = 1,
        Origin = "Bottom",
        FollowMouse = false,
        Outline = true
    },
    WrappedObjects = {},
    TracerLibraries = {},
    TracerConnections = {}
}

local Environment = getgenv().SimpleESP

local CoreFunctions = {
    GetColorFromHealth = function(health, max)
        return Color3fromRGB(
            255 - mathfloor(health / max * 255),
            mathfloor(health / max * 255),
            Environment.HealthBar.Blue
        )
    end,
    GetTeamColor = function(player)
        if Environment.Settings.TeamBasedColors then
            return player.Team == LocalPlayer.Team and Environment.Settings.TeamColor or Environment.Settings.EnemyColor
        end
        return Environment.Box.Color
    end,
    GetTracerColor = function(player)
        if Environment.Settings.TeamBasedColors then
            return player.Team == LocalPlayer.Team and Environment.Settings.TeamColor or Environment.Tracer.Color
        end
        return Environment.Tracer.Color
    end,
    CalculateBox = function(character)
        local root = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not root then return nil, nil, false end
        
        local rigType = character:FindFirstChild("Torso") and "R6" or "R15"
        local cameraUpVector = CurrentCamera.CFrame.UpVector
        local rootUpVector = root.CFrame.UpVector
        
        local topOffset, bottomOffset
        if rigType == "R6" then
            topOffset = rootUpVector * 0.5 + cameraUpVector
            bottomOffset = rootUpVector * -4 - cameraUpVector
        else
            topOffset = rootUpVector * 1.8 + cameraUpVector
            bottomOffset = rootUpVector * -2.5 - cameraUpVector
        end
        
        local top = root.Position + topOffset
        local bottom = root.Position + bottomOffset
        
        local topScreen, topVisible = WorldToViewportPoint(top)
        local bottomScreen, bottomVisible = WorldToViewportPoint(bottom)
        
        if not (topVisible and bottomVisible) then 
            return nil, nil, false 
        end
        
        local width = mathfloor(math.abs(topScreen.X - bottomScreen.X))
        local height = mathfloor(math.max(math.abs(bottomScreen.Y - topScreen.Y), width / 2))
        width = math.max(width, 3)
        height = math.max(height, 3)
        
        local boxWidth = mathfloor(math.max(height / 1.5, width))
        local size = Vector2new(boxWidth, height)
        local position = Vector2.new(
            mathfloor((topScreen.X + bottomScreen.X) / 2 - boxWidth / 2),
            mathfloor(math.min(topScreen.Y, bottomScreen.Y))
        )
        
        return position, size, true
    end
}

local function CreateVisuals(player)
    local fillBox = Drawingnew("Square")
    local boxOutline = Drawingnew("Square")
    local box = Drawingnew("Square")
    local healthOutline = Drawingnew("Line")
    local healthBar = Drawingnew("Line")
    
    box.Visible = false
    boxOutline.Visible = false
    fillBox.Visible = false
    healthBar.Visible = false
    healthOutline.Visible = false
    
    return {
        Box = {box, boxOutline, fillBox},
        HealthBar = {healthBar, healthOutline},
        Player = player
    }
end

local function UpdateVisuals(entry)
    local visuals = entry.Visuals
    local player = entry.Player
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")
    
    if not character or not humanoid or (Environment.Settings.AliveCheck and humanoid.Health <= 0) then
        for _, obj in pairs(visuals.Box) do obj.Visible = false end
        for _, obj in pairs(visuals.HealthBar) do obj.Visible = false end
        return
    end
    
    if Environment.Settings.TeamCheck and player.Team == LocalPlayer.Team then
        for _, obj in pairs(visuals.Box) do obj.Visible = false end
        for _, obj in pairs(visuals.HealthBar) do obj.Visible = false end
        return
    end
    
    local position, size, visible = CoreFunctions.CalculateBox(character)
    if not visible then
        for _, obj in pairs(visuals.Box) do obj.Visible = false end
        for _, obj in pairs(visuals.HealthBar) do obj.Visible = false end
        return
    end
    
    local box, boxOutline, fillBox = unpack(visuals.Box)
    local healthBar, healthOutline = unpack(visuals.HealthBar)
    
    box.Position = position
    box.Size = size
    box.Color = CoreFunctions.GetTeamColor(player)
    box.Transparency = Environment.Box.Transparency
    box.Filled = false
    box.Thickness = Environment.Box.Thickness
    box.Visible = Environment.Settings.Enabled and Environment.Box.Enabled and visible
    
    if Environment.Box.FillEnabled then
        fillBox.Position = position
        fillBox.Size = size
        fillBox.Color = CoreFunctions.GetTeamColor(player)
        fillBox.Transparency = Environment.Box.FillTransparency
        fillBox.Filled = true
        fillBox.Visible = box.Visible
    else
        fillBox.Visible = false
    end

    if Environment.Box.Outline then
        boxOutline.Position = position
        boxOutline.Size = size
        boxOutline.Color = Environment.Box.OutlineColor
        boxOutline.Thickness = Environment.Box.Thickness + 1
        boxOutline.Transparency = Environment.Box.Transparency
        boxOutline.Visible = box.Visible
    else
        boxOutline.Visible = false
    end
    
    if Environment.HealthBar.Enabled then
        local health = math.clamp(humanoid.Health, 0, humanoid.MaxHealth)
        local ratio = health / humanoid.MaxHealth
        local offset = Environment.HealthBar.Offset
        
        local barHeight = size.Y
        local barWidth = Environment.HealthBar.Thickness
        local barX = position.X - offset
        
        healthBar.From = Vector2new(barX, position.Y + barHeight)
        healthBar.To = Vector2new(barX, position.Y + barHeight - ratio * barHeight)
        healthBar.Color = CoreFunctions.GetColorFromHealth(health, humanoid.MaxHealth)
        healthBar.Thickness = barWidth
        healthBar.Transparency = Environment.HealthBar.Transparency
        healthBar.Visible = Environment.Settings.Enabled and visible
        
        if Environment.HealthBar.Outline then
            healthOutline.From = Vector2new(barX, position.Y + barHeight + 1)
            healthOutline.To = Vector2new(barX, position.Y - 1)
            healthOutline.Color = Environment.HealthBar.OutlineColor
            healthOutline.Thickness = barWidth + 1
            healthOutline.Transparency = Environment.HealthBar.Transparency
            healthOutline.Visible = healthBar.Visible
        else
            healthOutline.Visible = false
        end
    else
        healthBar.Visible = false
        healthOutline.Visible = false
    end
end

local function InitESP()
    for _, player in ipairs(GetPlayers()) do
        if player ~= LocalPlayer then
            local entry = {
                Visuals = CreateVisuals(player),
                Player = player
            }
            Environment.WrappedObjects[player] = entry
            
            local connection
            connection = RunService.RenderStepped:Connect(function()
                if not Environment.WrappedObjects[player] then
                    connection:Disconnect()
                    return
                end
                UpdateVisuals(entry)
            end)
        end
    end
    
    Players.PlayerAdded:Connect(function(newPlayer)
        if newPlayer == LocalPlayer then return end
        
        local entry = {
            Visuals = CreateVisuals(newPlayer),
            Player = newPlayer
        }
        Environment.WrappedObjects[newPlayer] = entry
        
        local connection
        connection = RunService.RenderStepped:Connect(function()
            if not Environment.WrappedObjects[newPlayer] then
                connection:Disconnect()
                return
            end
            UpdateVisuals(entry)
        end)
    end)
    
    Players.PlayerRemoving:Connect(function(leftPlayer)
        local entry = Environment.WrappedObjects[leftPlayer]
        if entry then
            for _, obj in pairs(entry.Visuals.Box) do obj:Remove() end
            for _, obj in pairs(entry.Visuals.HealthBar) do obj:Remove() end
            Environment.WrappedObjects[leftPlayer] = nil
        end
    end)
end

local function NewLine(thickness, color, zindex)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    line.ZIndex = zindex
    return line
end

local function TracerESP(plr)
    local library = {
        blacktracer = NewLine(Environment.Tracer.Thickness * 2, Color3.new(0, 0, 0), 1),
        tracer = NewLine(Environment.Tracer.Thickness, Environment.Tracer.Color, 2)
    }

    Environment.TracerLibraries[plr] = library

    local function Cleanup()
        library.tracer:Remove()
        library.blacktracer:Remove()
        Environment.TracerLibraries[plr] = nil
    end

    local function Updater()
        local renderConnection
        local characterConnection

        local function UpdateTracer()
            if renderConnection then renderConnection:Disconnect() end

            renderConnection = RunService.RenderStepped:Connect(function()
                pcall(function()
                    if not Players:FindFirstChild(plr.Name) then
                        Cleanup()
                        renderConnection:Disconnect()
                        if characterConnection then characterConnection:Disconnect() end
                        Environment.TracerConnections[plr] = nil
                        return
                    end

                    if not Environment.Settings.Enabled or not Environment.Tracer.Enabled then
                        library.tracer.Visible = false
                        library.blacktracer.Visible = false
                        return
                    end

                    if Environment.Settings.TeamCheck and plr.Team == LocalPlayer.Team then
                        library.tracer.Visible = false
                        library.blacktracer.Visible = false
                        return
                    end

                    if plr.Character and plr.Character:FindFirstChild("Humanoid") and 
                       plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 and 
                       plr.Character:FindFirstChild("Head") then
                       
                        local rootPos, onScreen = CurrentCamera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                        local headPos = CurrentCamera:WorldToViewportPoint(plr.Character.Head.Position)
                        local distanceY = math.clamp((Vector2.new(headPos.X, headPos.Y) - Vector2.new(rootPos.X, rootPos.Y)).magnitude, 2, math.huge)

                        if not onScreen then
                            library.tracer.Visible = false
                            library.blacktracer.Visible = false
                            return
                        end

                        local fromPos
                        if Environment.Tracer.Origin == "Center" then
                            fromPos = CurrentCamera.ViewportSize * 0.5
                        elseif Environment.Tracer.Origin == "Top" then
                            fromPos = Vector2.new(CurrentCamera.ViewportSize.X * 0.5, 0)
                        else
                            fromPos = Vector2.new(CurrentCamera.ViewportSize.X * 0.5, CurrentCamera.ViewportSize.Y)
                        end
                        
                        if Environment.Tracer.FollowMouse then
                            fromPos = Vector2.new(game:GetService("Players").LocalPlayer:GetMouse().X, game:GetService("Players").LocalPlayer:GetMouse().Y + 36)
                        end
                        
                        library.tracer.From = fromPos
                        library.blacktracer.From = fromPos

                        local toPos
                        if Environment.Tracer.Origin == "Top" then
                            toPos = Vector2.new(headPos.X, headPos.Y - distanceY)
                        else
                            toPos = Vector2.new(rootPos.X, rootPos.Y + distanceY * 2)
                        end
                        
                        library.tracer.To = toPos
                        library.blacktracer.To = toPos
                        
                        library.tracer.Color = CoreFunctions.GetTracerColor(plr)
                        library.tracer.Visible = true
                        library.blacktracer.Visible = Environment.Tracer.Outline
                    else
                        library.tracer.Visible = false
                        library.blacktracer.Visible = false
                    end
                end)
            end)
        end

        characterConnection = plr.CharacterAdded:Connect(UpdateTracer)
        UpdateTracer()
        Environment.TracerConnections[plr] = {renderConnection, characterConnection}
    end
    coroutine.wrap(Updater)()
end

for _, v in ipairs(Players:GetPlayers()) do
    if v ~= LocalPlayer then
        coroutine.wrap(TracerESP)(v)
    end
end

Players.PlayerAdded:Connect(function(newplr)
    if newplr ~= LocalPlayer then
        coroutine.wrap(TracerESP)(newplr)
    end
end)

Players.PlayerRemoving:Connect(function(plr)
    if Environment.TracerConnections[plr] then
        for _, conn in ipairs(Environment.TracerConnections[plr]) do
            conn:Disconnect()
        end
        Environment.TracerConnections[plr] = nil
    end
    if Environment.TracerLibraries[plr] then
        local lib = Environment.TracerLibraries[plr]
        lib.tracer:Remove()
        lib.blacktracer:Remove()
        Environment.TracerLibraries[plr] = nil
    end
end)

InitESP()
return Environment
