getgenv().SimpleESP = {
    Settings = {
        Enabled = false,
        TeamCheck = false,
        TeamColor = Color3.fromRGB(170, 170, 255),
        AliveCheck = true
    },
    Box2D = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 1,
        Thickness = 1,
        OutlineColor = Color3.fromRGB(0, 0, 0),
        Outline = false,
        FillEnabled = false,
        FillTransparency = 0.5,
        HealthBar = {
            Enabled = false,
            Offset = 4,
            Blue = 100,
            Thickness = 1,
            Transparency = 1,
            OutlineColor = Color3.fromRGB(0, 0, 0),
            Outline = false
        },
        WrappedObjects = {}
    },
    Box3D = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        BoxOutlineEnabled = false,
        BoxOutlineColor = Color3.fromRGB(0, 0, 0),
        BoxOutlineThickness = 2,
        BoxFillEnabled = false,
        FillTransparency = 0.5
    },
    CornerBox = {
        Enabled = false,
        BoxColor = Color3.new(1, 1, 1),
        LineWidth = 0.25,
        LineHeight = 0.2,
        VerticalLineOffset = 0.001,
        LineThickness = 1,
        WidthMultiplier = 1.5,
        HeightMultiplier = 2.2,
        YOffset = 1.8,
        XOffset = 1.5,
        cache = {}
    },
    Arrows = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 0,
        Outline = false
    },
    Skeleton = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Thickness = 1
    },
    Text = {
        NameEnabled = false,
        DistanceEnabled = false,
        NameColor = Color3.fromRGB(255, 255, 255),
        DistanceColor = Color3.fromRGB(255, 255, 255),
        Outline = false
    },
    Tracer = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Thickness = 1,
        Origin = "Bottom",
        Outline = false
    },
    Chams = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 0.5
    }
}

local env = getgenv().SimpleESP
local game = game
local Vector2new = Vector2.new
local Drawingnew = Drawing.new
local Color3fromRGB = Color3.fromRGB
local mathfloor, mathabs, mathclamp, mathrad = math.floor, math.abs, math.clamp, math.rad
local wait, spawn = task.wait, task.spawn
local getgenv, cloneref = getgenv, cloneref or function(v) return v end

local GameMetatable = getrawmetatable and getrawmetatable(game) or {}
local __index = GameMetatable.__index or function(self, idx) return self[idx] end
local __newindex = GameMetatable.__newindex or function(self, idx, val) self[idx] = val end
local setrenderproperty = setrenderproperty or __newindex

local Workspace = cloneref(game:GetService("Workspace"))
local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local TweenService = cloneref(game:GetService("TweenService"))

local CurrentCamera = __index(Workspace, "CurrentCamera")
local LocalPlayer = __index(Players, "LocalPlayer")

local WorldToViewportPoint = function(...) return CurrentCamera.WorldToViewportPoint(CurrentCamera, ...) end
local GetPlayers = function() return Players:GetPlayers() end
local GetPlayerFromCharacter = function(...) return Players:GetPlayerFromCharacter(...) end
local IsDescendantOf = function(self, parent) return self:IsDescendantOf(parent) end

local function GetTeamColor(player)
    if env.Settings.TeamCheck and player.Team == LocalPlayer.Team then
        return env.Settings.TeamColor
    end
    return env.Box2D.Color
end

local function GetColorFromHealth(health, max)
    return Color3fromRGB(
        255 - mathfloor(health / max * 255),
        mathfloor(health / max * 255),
        env.Box2D.HealthBar.Blue
    )
end

local function CalculateBox(character)
    local root = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
    if not root then return nil, nil, false end
    
    local rigType = character:FindFirstChild("Torso") and "R6" or "R15"
    local cameraUpVector = CurrentCamera.CFrame.UpVector
    local rootUpVector = root.CFrame.UpVector
    
    local topOffset, bottomOffset
    if rigType == "R6" then
        topOffset = rootUpVector * 0.5 + cameraUpVector
        bottomOffset = rootUpVector * -4 - cameraUpVector
    else
        topOffset = rootUpVector * 1.8 + cameraUpVector
        bottomOffset = rootUpVector * -2.5 - cameraUpVector
    end
    
    local top = root.Position + topOffset
    local bottom = root.Position + bottomOffset
    
    local topX, topY, topZ, topVisible = WorldToViewportPoint(top)
    local bottomX, bottomY, bottomZ, bottomVisible = WorldToViewportPoint(bottom)
    
    if not (topVisible and bottomVisible) then 
        return nil, nil, false 
    end
    
    local topScreen = Vector2.new(topX, topY)
    local bottomScreen = Vector2.new(bottomX, bottomY)
    
    local width = mathfloor(math.abs(topScreen.X - bottomScreen.X))
    local height = mathfloor(math.max(math.abs(bottomScreen.Y - topScreen.Y), width / 2))
    width = math.max(width, 3)
    height = math.max(height, 3)
    
    local boxWidth = mathfloor(math.max(height / 1.5, width))
    local size = Vector2new(boxWidth, height)
    local position = Vector2.new(
        mathfloor((topScreen.X + bottomScreen.X) / 2 - boxWidth / 2),
        mathfloor(math.min(topScreen.Y, bottomScreen.Y))
    )
    
    return position, size, true
end

local function CreateVisuals(player)
    local fillBox = Drawingnew("Square")
    local boxOutline = Drawingnew("Square")
    local box = Drawingnew("Square")
    local healthOutline = Drawingnew("Line")
    local healthBar = Drawingnew("Line")
    
    box.Visible = false
    boxOutline.Visible = false
    fillBox.Visible = false
    healthBar.Visible = false
    healthOutline.Visible = false
    
    return {
        Box = {box, boxOutline, fillBox},
        HealthBar = {healthBar, healthOutline},
        Player = player
    }
end

local function Update2DBox(entry)
    local visuals = entry.Visuals
    local player = entry.Player
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")
    
    if not env.Settings.Enabled or not env.Box2D.Enabled then
        for _, obj in pairs(visuals.Box) do obj.Visible = false end
        for _, obj in pairs(visuals.HealthBar) do obj.Visible = false end
        return
    end
    
    if not character or not humanoid or (env.Settings.AliveCheck and humanoid.Health <= 0) then
        for _, obj in pairs(visuals.Box) do obj.Visible = false end
        for _, obj in pairs(visuals.HealthBar) do obj.Visible = false end
        return
    end
    
    local position, size, visible = CalculateBox(character)
    if not visible then
        for _, obj in pairs(visuals.Box) do obj.Visible = false end
        for _, obj in pairs(visuals.HealthBar) do obj.Visible = false end
        return
    end
    
    local box, boxOutline, fillBox = unpack(visuals.Box)
    local healthBar, healthOutline = unpack(visuals.HealthBar)
    
    box.Position = position
    box.Size = size
    box.Color = GetTeamColor(player)
    box.Transparency = env.Box2D.Transparency
    box.Filled = false
    box.Thickness = env.Box2D.Thickness
    box.Visible = true
    
    if env.Box2D.FillEnabled then
        fillBox.Position = position
        fillBox.Size = size
        fillBox.Color = GetTeamColor(player)
        fillBox.Transparency = env.Box2D.FillTransparency
        fillBox.Filled = true
        fillBox.Visible = true
    else
        fillBox.Visible = false
    end

    if env.Box2D.Outline then
        boxOutline.Position = position
        boxOutline.Size = size
        boxOutline.Color = env.Box2D.OutlineColor
        boxOutline.Thickness = env.Box2D.Thickness + 1
        boxOutline.Transparency = env.Box2D.Transparency
        boxOutline.Visible = true
    else
        boxOutline.Visible = false
    end
    
    if env.Box2D.HealthBar.Enabled then
        local health = math.clamp(humanoid.Health, 0, humanoid.MaxHealth)
        local ratio = health / humanoid.MaxHealth
        local offset = env.Box2D.HealthBar.Offset
        
        local barHeight = size.Y
        local barWidth = env.Box2D.HealthBar.Thickness
        local barX = position.X - offset
        
        healthBar.From = Vector2new(barX, position.Y + barHeight)
        healthBar.To = Vector2new(barX, position.Y + barHeight - ratio * barHeight)
        healthBar.Color = GetColorFromHealth(health, humanoid.MaxHealth)
        healthBar.Thickness = barWidth
        healthBar.Transparency = env.Box2D.HealthBar.Transparency
        healthBar.Visible = true
        
        if env.Box2D.HealthBar.Outline then
            healthOutline.From = Vector2new(barX, position.Y + barHeight + 1)
            healthOutline.To = Vector2new(barX, position.Y - 1)
            healthOutline.Color = env.Box2D.HealthBar.OutlineColor
            healthOutline.Thickness = barWidth + 1
            healthOutline.Transparency = env.Box2D.HealthBar.Transparency
            healthOutline.Visible = true
        else
            healthOutline.Visible = false
        end
    else
        healthBar.Visible = false
        healthOutline.Visible = false
    end
end

local function Init2DBox()
    for _, player in ipairs(GetPlayers()) do
        if player ~= LocalPlayer then
            local entry = {
                Visuals = CreateVisuals(player),
                Player = player
            }
            env.Box2D.WrappedObjects[player] = entry
            
            local connection
            connection = RunService.RenderStepped:Connect(function()
                if not env.Box2D.WrappedObjects[player] then
                    connection:Disconnect()
                    return
                end
                Update2DBox(entry)
            end)
        end
    end
    
    Players.PlayerAdded:Connect(function(newPlayer)
        if newPlayer == LocalPlayer then return end
        
        local entry = {
            Visuals = CreateVisuals(newPlayer),
            Player = newPlayer
        }
        env.Box2D.WrappedObjects[newPlayer] = entry
        
        local connection
        connection = RunService.RenderStepped:Connect(function()
            if not env.Box2D.WrappedObjects[newPlayer] then
                connection:Disconnect()
                return
            end
            Update2DBox(entry)
        end)
    end)
    
    Players.PlayerRemoving:Connect(function(leftPlayer)
        local entry = env.Box2D.WrappedObjects[leftPlayer]
        if entry then
            for _, obj in pairs(entry.Visuals.Box) do obj:Remove() end
            for _, obj in pairs(entry.Visuals.HealthBar) do obj:Remove() end
            env.Box2D.WrappedObjects[leftPlayer] = nil
        end
    end)
end

local Box3DConnections = {}
local Box3DLibraries = {}
local function NewLine(thickness, color, isOutline)
    local line = Drawingnew("Line")
    line.Visible = false
    line.Color = color
    line.Thickness = isOutline and env.Box3D.BoxOutlineThickness or thickness
    return line
end

local function NewQuad(color, transparency)
    local quad = Drawingnew("Quad")
    quad.Visible = false
    quad.Color = color
    quad.Transparency = transparency
    quad.Thickness = 0.5
    quad.Filled = true
    return quad
end

local function Box3DESP(plr)
    local library = {
        box_line1 = NewLine(1, env.Box3D.Color),
        box_line2 = NewLine(1, env.Box3D.Color),
        box_line3 = NewLine(1, env.Box3D.Color),
        box_line4 = NewLine(1, env.Box3D.Color),
        box_line5 = NewLine(1, env.Box3D.Color),
        box_line6 = NewLine(1, env.Box3D.Color),
        box_line7 = NewLine(1, env.Box3D.Color),
        box_line8 = NewLine(1, env.Box3D.Color),
        box_line9 = NewLine(1, env.Box3D.Color),
        box_line10 = NewLine(1, env.Box3D.Color),
        box_line11 = NewLine(1, env.Box3D.Color),
        box_line12 = NewLine(1, env.Box3D.Color),
        box_line_black1 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black2 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black3 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black4 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black5 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black6 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black7 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black8 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black9 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black10 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black11 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_line_black12 = NewLine(1, env.Box3D.BoxOutlineColor, true),
        box_quad1 = NewQuad(env.Box3D.Color, env.Box3D.FillTransparency),
        box_quad2 = NewQuad(env.Box3D.Color, env.Box3D.FillTransparency),
        box_quad3 = NewQuad(env.Box3D.Color, env.Box3D.FillTransparency),
        box_quad4 = NewQuad(env.Box3D.Color, env.Box3D.FillTransparency),
        box_quad5 = NewQuad(env.Box3D.Color, env.Box3D.FillTransparency),
        box_quad6 = NewQuad(env.Box3D.Color, env.Box3D.FillTransparency)
    }

    Box3DLibraries[plr.Name] = library

    local function Cleanup()
        for i = 1, 12 do
            library["box_line" .. i]:Remove()
            library["box_line_black" .. i]:Remove()
        end
        for i = 1, 6 do
            library["box_quad" .. i]:Remove()
        end
        Box3DLibraries[plr.Name] = nil
    end

    local function Updater()
        local renderConnection
        local characterConnection

        local function UpdateESP()
            if renderConnection then renderConnection:Disconnect() end
            renderConnection = RunService.RenderStepped:Connect(function()
                pcall(function()
                    if not Players:FindFirstChild(plr.Name) then
                        Cleanup()
                        renderConnection:Disconnect()
                        if characterConnection then characterConnection:Disconnect() end
                        Box3DConnections[plr.Name] = nil
                        return
                    end

                    if not env.Settings.Enabled or not env.Box3D.Enabled then
                        for i = 1, 12 do
                            library["box_line" .. i].Visible = false
                            library["box_line_black" .. i].Visible = false
                        end
                        for i = 1, 6 do
                            library["box_quad" .. i].Visible = false
                        end
                        return
                    end

                    if plr.Character and plr.Character:FindFirstChild("Humanoid") and 
                       plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 then

                        local hrp = plr.Character.HumanoidRootPart
                        local hrpPos, onScreen = CurrentCamera:WorldToViewportPoint(hrp.Position)

                        if onScreen then
                            local Size = Vector3.new(2, 3, 2)
                            local Top1 = CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-Size.X, Size.Y, -Size.Z)).p)
                            local Top2 = CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-Size.X, Size.Y, Size.Z)).p)
                            local Top3 = CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(Size.X, Size.Y, Size.Z)).p)
                            local Top4 = CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(Size.X, Size.Y, -Size.Z)).p)
                            local Bottom1 = CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-Size.X, -Size.Y, -Size.Z)).p)
                            local Bottom2 = CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-Size.X, -Size.Y, Size.Z)).p)
                            local Bottom3 = CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(Size.X, -Size.Y, Size.Z)).p)
                            local Bottom4 = CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(Size.X, -Size.Y, -Size.Z)).p)

                            library.box_line1.From = Vector2.new(Top1.X, Top1.Y)
                            library.box_line1.To = Vector2.new(Top2.X, Top2.Y)
                            library.box_line2.From = Vector2.new(Top2.X, Top2.Y)
                            library.box_line2.To = Vector2.new(Top3.X, Top3.Y)
                            library.box_line3.From = Vector2.new(Top3.X, Top3.Y)
                            library.box_line3.To = Vector2.new(Top4.X, Top4.Y)
                            library.box_line4.From = Vector2.new(Top4.X, Top4.Y)
                            library.box_line4.To = Vector2.new(Top1.X, Top1.Y)
                            library.box_line5.From = Vector2.new(Bottom1.X, Bottom1.Y)
                            library.box_line5.To = Vector2.new(Bottom2.X, Bottom2.Y)
                            library.box_line6.From = Vector2.new(Bottom2.X, Bottom2.Y)
                            library.box_line6.To = Vector2.new(Bottom3.X, Bottom3.Y)
                            library.box_line7.From = Vector2.new(Bottom3.X, Bottom3.Y)
                            library.box_line7.To = Vector2.new(Bottom4.X, Bottom4.Y)
                            library.box_line8.From = Vector2.new(Bottom4.X, Bottom4.Y)
                            library.box_line8.To = Vector2.new(Bottom1.X, Bottom1.Y)
                            library.box_line9.From = Vector2.new(Bottom1.X, Bottom1.Y)
                            library.box_line9.To = Vector2.new(Top1.X, Top1.Y)
                            library.box_line10.From = Vector2.new(Bottom2.X, Bottom2.Y)
                            library.box_line10.To = Vector2.new(Top2.X, Top2.Y)
                            library.box_line11.From = Vector2.new(Bottom3.X, Bottom3.Y)
                            library.box_line11.To = Vector2.new(Top3.X, Top3.Y)
                            library.box_line12.From = Vector2.new(Bottom4.X, Bottom4.Y)
                            library.box_line12.To = Vector2.new(Top4.X, Top4.Y)

                            library.box_line_black1.From = Vector2.new(Top1.X, Top1.Y)
                            library.box_line_black1.To = Vector2.new(Top2.X, Top2.Y)
                            library.box_line_black2.From = Vector2.new(Top2.X, Top2.Y)
                            library.box_line_black2.To = Vector2.new(Top3.X, Top3.Y)
                            library.box_line_black3.From = Vector2.new(Top3.X, Top3.Y)
                            library.box_line_black3.To = Vector2.new(Top4.X, Top4.Y)
                            library.box_line_black4.From = Vector2.new(Top4.X, Top4.Y)
                            library.box_line_black4.To = Vector2.new(Top1.X, Top1.Y)
                            library.box_line_black5.From = Vector2.new(Bottom1.X, Bottom1.Y)
                            library.box_line_black5.To = Vector2.new(Bottom2.X, Bottom2.Y)
                            library.box_line_black6.From = Vector2.new(Bottom2.X, Bottom2.Y)
                            library.box_line_black6.To = Vector2.new(Bottom3.X, Bottom3.Y)
                            library.box_line_black7.From = Vector2.new(Bottom3.X, Bottom3.Y)
                            library.box_line_black7.To = Vector2.new(Bottom4.X, Bottom4.Y)
                            library.box_line_black8.From = Vector2.new(Bottom4.X, Bottom4.Y)
                            library.box_line_black8.To = Vector2.new(Bottom1.X, Bottom1.Y)
                            library.box_line_black9.From = Vector2.new(Bottom1.X, Bottom1.Y)
                            library.box_line_black9.To = Vector2.new(Top1.X, Top1.Y)
                            library.box_line_black10.From = Vector2.new(Bottom2.X, Bottom2.Y)
                            library.box_line_black10.To = Vector2.new(Top2.X, Top2.Y)
                            library.box_line_black11.From = Vector2.new(Bottom3.X, Bottom3.Y)
                            library.box_line_black11.To = Vector2.new(Top3.X, Top3.Y)
                            library.box_line_black12.From = Vector2.new(Bottom4.X, Bottom4.Y)
                            library.box_line_black12.To = Vector2.new(Top4.X, Top4.Y)

                            if env.Box3D.BoxFillEnabled then
                                library.box_quad1.PointA = Vector2.new(Bottom1.X, Bottom1.Y)
                                library.box_quad1.PointB = Vector2.new(Bottom2.X, Bottom2.Y)
                                library.box_quad1.PointC = Vector2.new(Bottom3.X, Bottom3.Y)
                                library.box_quad1.PointD = Vector2.new(Bottom4.X, Bottom4.Y)

                                library.box_quad2.PointA = Vector2.new(Top1.X, Top1.Y)
                                library.box_quad2.PointB = Vector2.new(Top2.X, Top2.Y)
                                library.box_quad2.PointC = Vector2.new(Top3.X, Top3.Y)
                                library.box_quad2.PointD = Vector2.new(Top4.X, Top4.Y)

                                library.box_quad3.PointA = Vector2.new(Bottom1.X, Bottom1.Y)
                                library.box_quad3.PointB = Vector2.new(Top1.X, Top1.Y)
                                library.box_quad3.PointC = Vector2.new(Top4.X, Top4.Y)
                                library.box_quad3.PointD = Vector2.new(Bottom4.X, Bottom4.Y)

                                library.box_quad4.PointA = Vector2.new(Bottom2.X, Bottom2.Y)
                                library.box_quad4.PointB = Vector2.new(Top2.X, Top2.Y)
                                library.box_quad4.PointC = Vector2.new(Top3.X, Top3.Y)
                                library.box_quad4.PointD = Vector2.new(Bottom3.X, Bottom3.Y)

                                library.box_quad5.PointA = Vector2.new(Bottom1.X, Bottom1.Y)
                                library.box_quad5.PointB = Vector2.new(Top1.X, Top1.Y)
                                library.box_quad5.PointC = Vector2.new(Top2.X, Top2.Y)
                                library.box_quad5.PointD = Vector2.new(Bottom2.X, Bottom2.Y)

                                library.box_quad6.PointA = Vector2.new(Bottom3.X, Bottom3.Y)
                                library.box_quad6.PointB = Vector2.new(Top3.X, Top3.Y)
                                library.box_quad6.PointC = Vector2.new(Top4.X, Top4.Y)
                                library.box_quad6.PointD = Vector2.new(Bottom4.X, Bottom4.Y)
                            end

                            for i = 1, 12 do
                                library["box_line" .. i].Visible = true
                                library["box_line_black" .. i].Visible = env.Box3D.BoxOutlineEnabled
                            end
                            for i = 1, 6 do
                                library["box_quad" .. i].Visible = env.Box3D.BoxFillEnabled
                            end
                        else
                            for i = 1, 12 do
                                library["box_line" .. i].Visible = false
                                library["box_line_black" .. i].Visible = false
                            end
                            for i = 1, 6 do
                                library["box_quad" .. i].Visible = false
                            end
                        end
                    else
                        for i = 1, 12 do
                            library["box_line" .. i].Visible = false
                            library["box_line_black" .. i].Visible = false
                        end
                        for i = 1, 6 do
                            library["box_quad" .. i].Visible = false
                        end
                    end
                end)
            end)
        end

        characterConnection = plr.CharacterAdded:Connect(UpdateESP)
        UpdateESP()
        Box3DConnections[plr.Name] = {renderConnection, characterConnection}
    end
    coroutine.wrap(Updater)()
end

local function Init3DBox()
    for _, v in pairs(Players:GetPlayers()) do
        if v.Name ~= LocalPlayer.Name then
            coroutine.wrap(Box3DESP)(v)
        end
    end

    Players.PlayerAdded:Connect(function(newplr)
        if newplr.Name ~= LocalPlayer.Name then
            coroutine.wrap(Box3DESP)(newplr)
        end
    end)

    Players.PlayerRemoving:Connect(function(plr)
        if Box3DConnections[plr.Name] then
            for _, conn in pairs(Box3DConnections[plr.Name]) do
                conn:Disconnect()
            end
            Box3DConnections[plr.Name] = nil
        end
        if Box3DLibraries[plr.Name] then
            for i = 1, 12 do
                Box3DLibraries[plr.Name]["box_line" .. i]:Remove()
                Box3DLibraries[plr.Name]["box_line_black" .. i]:Remove()
            end
            for i = 1, 6 do
                Box3DLibraries[plr.Name]["box_quad" .. i]:Remove()
            end
            Box3DLibraries[plr.Name] = nil
        end
    end)
end

local ArrowDrawings = {}
local function GetRelative(pos, char)
    if not char then return Vector2.new(0, 0) end
    local rootP = char.PrimaryPart.Position
    local camP = CurrentCamera.CFrame.Position
    local relative = CFrame.new(Vector3.new(rootP.X, camP.Y, rootP.Z), camP):PointToObjectSpace(pos)
    return Vector2.new(relative.X, relative.Z)
end

local function RotateVect(v, a)
    a = math.rad(a)
    local x = v.X * math.cos(a) - v.Y * math.sin(a)
    local y = v.X * math.sin(a) + v.Y * math.cos(a)
    return Vector2.new(x, y)
end

local function UpdateArrow(plr)
    if not ArrowDrawings[plr] then
        local arrowFill = Drawingnew("Triangle")
        arrowFill.Visible = false
        arrowFill.Filled = true
        arrowFill.Thickness = 1
        arrowFill.Transparency = 1 - env.Arrows.Transparency
        arrowFill.Color = env.Arrows.Color
        arrowFill.ZIndex = 2

        local arrowOutline = Drawingnew("Triangle")
        arrowOutline.Visible = false
        arrowOutline.Filled = false
        arrowOutline.Thickness = 2
        arrowOutline.Transparency = 1
        arrowOutline.Color = Color3.fromRGB(0, 0, 0)
        arrowOutline.ZIndex = 1

        ArrowDrawings[plr] = {
            Fill = arrowFill,
            Outline = arrowOutline
        }
    end

    local arrowData = ArrowDrawings[plr]
    local arrowFill = arrowData.Fill
    local arrowOutline = arrowData.Outline

    if not env.Settings.Enabled or not env.Arrows.Enabled then
        arrowFill.Visible = false
        arrowOutline.Visible = false
        return
    end

    local char = plr.Character
    if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0 then
        local rootPart = char.HumanoidRootPart
        local _, onScreen = CurrentCamera:WorldToViewportPoint(rootPart.Position)

        if not onScreen then
            if env.Settings.TeamCheck and plr.Team == LocalPlayer.Team then
                arrowFill.Visible = false
                arrowOutline.Visible = false
                return
            end

            local rel = GetRelative(rootPart.Position, LocalPlayer.Character)
            if rel.Magnitude > 0.1 then
                local direction = rel.unit
                local base = direction * 80
                local sideLength = 8
                local baseL = base + RotateVect(direction, 90) * sideLength
                local baseR = base + RotateVect(direction, -90) * sideLength
                local tip = direction * (80 + 16)
                local center = CurrentCamera.ViewportSize / 2

                arrowFill.PointA = center + baseL
                arrowFill.PointB = center + baseR
                arrowFill.PointC = center + tip
                arrowOutline.PointA = center + baseL
                arrowOutline.PointB = center + baseR
                arrowOutline.PointC = center + tip

                arrowFill.Color = GetTeamColor(plr)
                arrowFill.Transparency = 1 - env.Arrows.Transparency
                arrowFill.Visible = true
                arrowOutline.Visible = env.Arrows.Outline
            else
                 arrowFill.Visible = false
                 arrowOutline.Visible = false
            end
        else
            arrowFill.Visible = false
            arrowOutline.Visible = false
        end
    else
        arrowFill.Visible = false
        arrowOutline.Visible = false
    end
end

local function RemoveArrow(plr)
    if ArrowDrawings[plr] then
        ArrowDrawings[plr].Fill:Remove()
        ArrowDrawings[plr].Outline:Remove()
        ArrowDrawings[plr] = nil
    end
end

local function InitArrows()
    RunService.RenderStepped:Connect(function()
        pcall(function()
            for _, plr in pairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer then
                    UpdateArrow(plr)
                end
            end
        end)
    end)

    Players.PlayerRemoving:Connect(function(plr)
        RemoveArrow(plr)
    end)
end

local function create(class, properties)
    local drawing = Drawing.new(class)
    for property, value in pairs(properties) do
        drawing[property] = value
    end
    return drawing
end

local function createCornerBox(player)
    if env.CornerBox.cache[player] then return end
    local character = player.Character
    if not character then return end
    local rootPart = character:WaitForChild("HumanoidRootPart", 1)
    if not rootPart then return end

    local esp = {
        boxLines = {}
    }
    env.CornerBox.cache[player] = esp
end

local function isPlayerBehindWall(player)
    local character = player.Character
    if not character then return false end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end

    local ray = Ray.new(CurrentCamera.CFrame.Position, (rootPart.Position - CurrentCamera.CFrame.Position).Unit * (rootPart.Position - CurrentCamera.CFrame.Position).Magnitude)
    local hit = Workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character, character})
    return hit and hit:IsA("Part")
end

local function removeCornerBox(player)
    local esp = env.CornerBox.cache[player]
    if not esp then return end
    
    for _, line in ipairs(esp.boxLines) do
        line:Remove()
    end
    
    env.CornerBox.cache[player] = nil
end

local function updateCornerBox()
    for player, esp in pairs(env.CornerBox.cache) do
        local character, team = player.Character, player.Team
        if character and (not env.Settings.TeamCheck or (team and team ~= LocalPlayer.Team)) then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local isBehindWall = isPlayerBehindWall(player)
            local shouldShow = not isBehindWall and env.Settings.Enabled and env.CornerBox.Enabled

            if rootPart and shouldShow then
                local position, onScreen = CurrentCamera:WorldToViewportPoint(rootPart.Position)
                if onScreen then
                    local charSize = (CurrentCamera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0)).Y -
                                   CurrentCamera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 2.6, 0)).Y) / 2

                    local boxSize = Vector2.new(
                        math.floor(charSize * env.CornerBox.WidthMultiplier),
                        math.floor(charSize * env.CornerBox.HeightMultiplier)
                    )
                    local boxPosition = Vector2.new(
                        math.floor(position.X - charSize * env.CornerBox.XOffset / 2),
                        math.floor(position.Y - charSize * env.CornerBox.YOffset / 2)
                    )

                    local lineW = boxSize.X * env.CornerBox.LineWidth
                    local lineH = boxSize.Y * env.CornerBox.LineHeight
                    local vertOffset = boxSize.Y * env.CornerBox.VerticalLineOffset

                    if #esp.boxLines == 0 then
                        for i = 1, 16 do
                            esp.boxLines[i] = create("Line", {
                                Thickness = i <= 8 and 3 or env.CornerBox.LineThickness,
                                Color = i <= 8 and Color3.new(0, 0, 0) or env.CornerBox.BoxColor,
                                ZIndex = i <= 8 and 1 or 2,
                                Transparency = 1
                            })
                        end
                    end

                    local lines = esp.boxLines

                    lines[1].From = Vector2.new(boxPosition.X, boxPosition.Y)
                    lines[1].To = Vector2.new(boxPosition.X + lineW, boxPosition.Y)
                    
                    lines[2].From = Vector2.new(boxPosition.X, boxPosition.Y - vertOffset)
                    lines[2].To = Vector2.new(boxPosition.X, boxPosition.Y - vertOffset + lineH)
                    
                    lines[3].From = Vector2.new(boxPosition.X + boxSize.X - lineW, boxPosition.Y)
                    lines[3].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y)
                    
                    lines[4].From = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y - vertOffset)
                    lines[4].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y - vertOffset + lineH)
                    
                    lines[5].From = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y - lineH - vertOffset)
                    lines[5].To = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y - vertOffset)
                    
                    lines[6].From = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y)
                    lines[6].To = Vector2.new(boxPosition.X + lineW, boxPosition.Y + boxSize.Y)
                    
                    lines[7].From = Vector2.new(boxPosition.X + boxSize.X - lineW, boxPosition.Y + boxSize.Y)
                    lines[7].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y)
                    
                    lines[8].From = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y - lineH - vertOffset)
                    lines[8].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y - vertOffset)

                    for i = 9, 16 do
                        lines[i].From = lines[i-8].From
                        lines[i].To = lines[i-8].To
                    end

                    for _, line in ipairs(lines) do
                        line.Visible = true
                    end
                else
                    for _, line in ipairs(esp.boxLines) do
                        line.Visible = false
                    end
                end
            else
                for _, line in ipairs(esp.boxLines) do
                    line.Visible = false
                end
            end
        else
            for _, line in ipairs(esp.boxLines) do
                line.Visible = false
            end
        end
    end
end

local function InitCornerBox()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            player.CharacterAdded:Connect(function(character)
                createCornerBox(player)
            end)
            player.CharacterRemoving:Connect(function(character)
                removeCornerBox(player)
            end)
            if player.Character then
                createCornerBox(player)
            end
        end
    end

    Players.PlayerAdded:Connect(function(player)
        if player ~= LocalPlayer then
            player.CharacterAdded:Connect(function(character)
                createCornerBox(player)
            end)
            player.CharacterRemoving:Connect(function(character)
                removeCornerBox(player)
            end)
            if player.Character then
                createCornerBox(player)
            end
        end
    end)

    Players.PlayerRemoving:Connect(removeCornerBox)

    RunService.RenderStepped:Connect(updateCornerBox)
end

local function InitChams()
    RunService.RenderStepped:Connect(function()
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local character = plr.Character
                local h = character and character:FindFirstChild("PlayerHighlight")
                local shouldHighlight = env.Settings.Enabled and env.Chams.Enabled and character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0
                if shouldHighlight and env.Settings.TeamCheck and plr.Team == LocalPlayer.Team then
                    shouldHighlight = false
                end
                if shouldHighlight then
                    if not h then
                        h = Instance.new("Highlight")
                        h.Name = "PlayerHighlight"
                        h.Adornee = character
                        h.Parent = character
                        h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                        h.OutlineTransparency = 0
                    end
                    h.FillColor = GetTeamColor(plr)
                    h.OutlineColor = GetTeamColor(plr)
                    h.FillTransparency = env.Chams.Transparency
                else
                    if h then
                        h:Destroy()
                    end
                end
            end
        end
    end)
end

local SkeletonConnections = {}
local SkeletonLibraries = {}
local bodyConnections = {
    R15 = {
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        {"LowerTorso", "LeftUpperLeg"},
        {"LowerTorso", "RightUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"},
        {"LeftLowerLeg", "LeftFoot"},
        {"RightUpperLeg", "RightLowerLeg"},
        {"RightLowerLeg", "RightFoot"},
        {"UpperTorso", "LeftUpperArm"},
        {"UpperTorso", "RightUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"},
        {"LeftLowerArm", "LeftHand"},
        {"RightUpperArm", "RightLowerArm"},
        {"RightUpperArm", "RightHand"}
    },
    R6 = {
        {"Head", "Torso"},
        {"Torso", "Left Arm"},
        {"Torso", "Right Arm"},
        {"Torso", "Left Leg"},
        {"Torso", "Right Leg"}
    }
}

local function SkeletonESP(plr)
    local library = {
        HeadCircle = Drawingnew("Circle"),
        SkeletonLines = {}
    }
    library.HeadCircle.Thickness = env.Skeleton.Thickness
    library.HeadCircle.Color = env.Skeleton.Color
    library.HeadCircle.Filled = false
    library.HeadCircle.Visible = false

    SkeletonLibraries[plr.Name] = library

    local function Cleanup()
        library.HeadCircle:Remove()
        for _, line in pairs(library.SkeletonLines) do
            line:Remove()
        end
        SkeletonLibraries[plr.Name] = nil
    end

    local function Updater()
        local renderConnection
        local characterConnection

        local function UpdateESP()
            if renderConnection then
                renderConnection:Disconnect()
            end

            renderConnection = RunService.RenderStepped:Connect(function()
                pcall(function()
                    if not Players:FindFirstChild(plr.Name) then
                        Cleanup()
                        renderConnection:Disconnect()
                        if characterConnection then
                            characterConnection:Disconnect()
                        end
                        SkeletonConnections[plr.Name] = nil
                        return
                    end

                    if not env.Settings.Enabled or not env.Skeleton.Enabled then
                        library.HeadCircle.Visible = false
                        for _, line in pairs(library.SkeletonLines) do
                            line.Visible = false
                        end
                        return
                    end

                    if plr.Character and plr.Character:FindFirstChild("Humanoid") and 
                       plr.Character:FindFirstChild("HumanoidRootPart") and 
                       plr.Character.Humanoid.Health > 0 and 
                       plr.Character:FindFirstChild("Head") then
                       
                        local hrp = plr.Character.HumanoidRootPart
                        local head = plr.Character.Head
                        local hrpPos, onScreen = CurrentCamera:WorldToViewportPoint(hrp.Position)
                        
                        if onScreen then
                            local headPos = CurrentCamera:WorldToViewportPoint(head.Position)
                            if headPos.Z > 0 then
                                local headSize = head.Size.X
                                local distance = headPos.Z
                                local fov = math.rad(CurrentCamera.FieldOfView / 2)
                                local scale = CurrentCamera.ViewportSize.Y / (2 * math.tan(fov) * distance)
                                local radius = headSize * scale * 0.5
                                local fixedRadius = (headSize * 0.5) * (1000 / (distance + 50))
                                library.HeadCircle.Radius = (radius + fixedRadius) / 2
                                library.HeadCircle.Position = Vector2.new(headPos.X, headPos.Y)
                                library.HeadCircle.Visible = distance < 298
                                library.HeadCircle.Color = GetTeamColor(plr)
                                
                                local connections = bodyConnections[plr.Character.Humanoid.RigType.Name] or {}
                                for _, connection in ipairs(connections) do
                                    local partA = plr.Character:FindFirstChild(connection[1])
                                    local partB = plr.Character:FindFirstChild(connection[2])
                                    if partA and partB then
                                        local line = library.SkeletonLines[connection[1].."-"..connection[2]] or Drawingnew("Line")
                                        line.Thickness = env.Skeleton.Thickness
                                        line.Color = GetTeamColor(plr)
                                        
                                        local posA = CurrentCamera:WorldToViewportPoint(partA.Position)
                                        local posB = CurrentCamera:WorldToViewportPoint(partB.Position)
                                        if partA.Name == "Head" then
                                            local direction = (Vector2.new(posB.X, posB.Y) - Vector2.new(posA.X, posA.Y)).Unit
                                            posA = Vector2.new(posA.X, posA.Y) + direction * library.HeadCircle.Radius
                                        elseif partB.Name == "Head" then
                                            local direction = (Vector2.new(posA.X, posA.Y) - Vector2.new(posB.X, posB.Y)).Unit
                                            posB = Vector2.new(posB.X, posB.Y) + direction * library.HeadCircle.Radius
                                        end
                                        line.From = Vector2.new(posA.X, posA.Y)
                                        line.To = Vector2.new(posB.X, posB.Y)
                                        line.Visible = true
                                        library.SkeletonLines[connection[1].."-"..connection[2]] = line
                                    end
                                end
                            else
                                library.HeadCircle.Visible = false
                            end
                        else
                            library.HeadCircle.Visible = false
                            for _, line in pairs(library.SkeletonLines) do
                                line.Visible = false
                            end
                        end
                    else
                        library.HeadCircle.Visible = false
                        for _, line in pairs(library.SkeletonLines) do
                            line.Visible = false
                        end
                    end
                end)
            end)
        end

        characterConnection = plr.CharacterAdded:Connect(UpdateESP)
        UpdateESP()
        SkeletonConnections[plr.Name] = {renderConnection, characterConnection}
    end
    coroutine.wrap(Updater)()
end

local function InitSkeleton()
    for _, v in pairs(Players:GetPlayers()) do
        if v.Name ~= LocalPlayer.Name then
            coroutine.wrap(SkeletonESP)(v)
        end
    end

    Players.PlayerAdded:Connect(function(newplr)
        if newplr.Name ~= LocalPlayer.Name then
            coroutine.wrap(SkeletonESP)(newplr)
        end
    end)

    Players.PlayerRemoving:Connect(function(plr)
        if SkeletonConnections[plr.Name] then
            for _, conn in pairs(SkeletonConnections[plr.Name]) do
                conn:Disconnect()
            end
            SkeletonConnections[plr.Name] = nil
        end
        if SkeletonLibraries[plr.Name] then
            SkeletonLibraries[plr.Name].HeadCircle:Remove()
            for _, line in pairs(SkeletonLibraries[plr.Name].SkeletonLines) do
                line:Remove()
            end
            SkeletonLibraries[plr.Name] = nil
        end
    end)
end

local TextConnections = {}
local TextLibraries = {}
local function TextESP(plr)
    local library = {
        name = Drawingnew("Text"),
        distance = Drawingnew("Text")
    }

    library.name.Font = 2
    library.distance.Font = 2
    library.name.Color = env.Text.NameColor
    library.name.Outline = env.Text.Outline
    library.name.Center = true
    library.name.Size = 13
    library.name.Visible = false
    library.distance.Color = env.Text.DistanceColor
    library.distance.Outline = env.Text.Outline
    library.distance.Center = true
    library.distance.Size = 12
    library.distance.Visible = false

    TextLibraries[plr.Name] = library

    local function Cleanup()
        library.name:Remove()
        library.distance:Remove()
        TextLibraries[plr.Name] = nil
    end

    local function Updater()
        local renderConnection
        local characterConnection

        local function UpdateESP()
            if renderConnection then
                renderConnection:Disconnect()
            end

            renderConnection = RunService.RenderStepped:Connect(function()
                pcall(function()
                    if not Players:FindFirstChild(plr.Name) then
                        Cleanup()
                        renderConnection:Disconnect()
                        if characterConnection then
                            characterConnection:Disconnect()
                        end
                        TextConnections[plr.Name] = nil
                        return
                    end

                    if not env.Settings.Enabled then
                        library.name.Visible = false
                        library.distance.Visible = false
                        return
                    end

                    if plr.Character and plr.Character:FindFirstChild("Humanoid") and 
                       plr.Character:FindFirstChild("HumanoidRootPart") and 
                       plr.Character.Humanoid.Health > 0 and 
                       plr.Character:FindFirstChild("Head") then
                        
                        local rootPart = plr.Character.HumanoidRootPart
                        local head = plr.Character.Head
                        local _, onScreen = CurrentCamera:WorldToViewportPoint(rootPart.Position)
                        
                        if onScreen then
                            local headPos = CurrentCamera:WorldToViewportPoint(head.Position)
                            if headPos.Z > 0 then
                                local distance = (CurrentCamera.CFrame.Position - rootPart.Position).Magnitude
                                local boxPosition = Vector2.new(headPos.X, headPos.Y - 20)
                                
                                if env.Settings.TeamCheck and plr.Team == LocalPlayer.Team then
                                    library.name.Visible = false
                                    library.distance.Visible = false
                                    return
                                end

                                if env.Text.NameEnabled then
                                    library.name.Visible = true
                                    library.name.Text = plr.Name
                                    library.name.Position = Vector2.new(boxPosition.X, boxPosition.Y)
                                    library.name.Color = GetTeamColor(plr)
                                end

                                if env.Text.DistanceEnabled then
                                    library.distance.Visible = true
                                    library.distance.Text = string.format("[%dm]", math.floor(distance))
                                    library.distance.Position = Vector2.new(boxPosition.X, boxPosition.Y + 15)
                                    library.distance.Color = GetTeamColor(plr)
                                end
                            else
                                library.name.Visible = false
                                library.distance.Visible = false
                            end
                        else
                            library.name.Visible = false
                            library.distance.Visible = false
                        end
                    else
                        library.name.Visible = false
                        library.distance.Visible = false
                    end
                end)
            end)
        end

        characterConnection = plr.CharacterAdded:Connect(UpdateESP)
        UpdateESP()
        TextConnections[plr.Name] = {renderConnection, characterConnection}
    end
    coroutine.wrap(Updater)()
end

local function InitText()
    for _, v in pairs(Players:GetPlayers()) do
        if v.Name ~= LocalPlayer.Name then
            coroutine.wrap(TextESP)(v)
        end
    end

    Players.PlayerAdded:Connect(function(newplr)
        if newplr.Name ~= LocalPlayer.Name then
            coroutine.wrap(TextESP)(newplr)
        end
    end)

    Players.PlayerRemoving:Connect(function(plr)
        if TextConnections[plr.Name] then
            for _, conn in pairs(TextConnections[plr.Name]) do
                conn:Disconnect()
            end
            TextConnections[plr.Name] = nil
        end
        if TextLibraries[plr.Name] then
            TextLibraries[plr.Name].name:Remove()
            TextLibraries[plr.Name].distance:Remove()
            TextLibraries[plr.Name] = nil
        end
    end)
end

local TracerConnections = {}
local TracerLibraries = {}
local function NewTracerLine(thickness, color, zindex, isOutline)
    local line = Drawingnew("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    line.ZIndex = zindex
    return line
end

local function TracerESP(plr)
    local library = {
        blacktracer = NewTracerLine(env.Tracer.Thickness * 2, Color3.new(0, 0, 0), 1),
        blacktracer2 = NewTracerLine(env.Tracer.Thickness * 2, Color3.new(0, 0, 0), 1),
        tracer = NewTracerLine(env.Tracer.Thickness, env.Tracer.Color, 2)
    }

    TracerLibraries[plr.Name] = library

    local function Cleanup()
        library.tracer:Remove()
        library.blacktracer:Remove()
        library.blacktracer2:Remove()
        TracerLibraries[plr.Name] = nil
    end

    local function Updater()
        local renderConnection
        local characterConnection

        local function UpdateESP()
            if renderConnection then
                renderConnection:Disconnect()
            end

            renderConnection = RunService.RenderStepped:Connect(function()
                pcall(function()
                    if not Players:FindFirstChild(plr.Name) then
                        Cleanup()
                        renderConnection:Disconnect()
                        if characterConnection then
                            characterConnection:Disconnect()
                        end
                        TracerConnections[plr.Name] = nil
                        return
                    end

                    if not env.Settings.Enabled or not env.Tracer.Enabled then
                        library.tracer.Visible = false
                        library.blacktracer.Visible = false
                        library.blacktracer2.Visible = false
                        return
                    end

                    if plr.Character and plr.Character:FindFirstChild("Humanoid") and 
                       plr.Character:FindFirstChild("HumanoidRootPart") and 
                       plr.Character.Humanoid.Health > 0 and 
                       plr.Character:FindFirstChild("Head") then
                       
                        local hrp = plr.Character.HumanoidRootPart
                        local head = plr.Character.Head
                        local HumPos, OnScreen = CurrentCamera:WorldToViewportPoint(hrp.Position)
                        local headPos = CurrentCamera:WorldToViewportPoint(head.Position)
                        local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)

                        if env.Settings.TeamCheck and plr.Team == LocalPlayer.Team then
                            library.tracer.Visible = false
                            library.blacktracer.Visible = false
                            library.blacktracer2.Visible = false
                            return
                        end

                        if OnScreen then
                            local fromPos
                            if env.Tracer.Origin == "Center" then
                                fromPos = CurrentCamera.ViewportSize * 0.5
                            elseif env.Tracer.Origin == "Top" then
                                fromPos = Vector2.new(CurrentCamera.ViewportSize.X * 0.5, 0)
                            elseif env.Tracer.Origin == "Bottom" then
                                fromPos = Vector2.new(CurrentCamera.ViewportSize.X * 0.5, CurrentCamera.ViewportSize.Y)
                            end
                            
                            local toPos
                            if env.Tracer.Origin == "Top" then
                                toPos = Vector2.new(headPos.X, headPos.Y - DistanceY)
                            else
                                toPos = Vector2.new(HumPos.X, HumPos.Y + DistanceY * 2)
                            end
                            
                            library.tracer.From = fromPos
                            library.tracer.To = toPos
                            library.blacktracer.From = fromPos
                            library.blacktracer.To = Vector2.new(toPos.X - env.Tracer.Thickness, toPos.Y)
                            library.blacktracer2.From = fromPos
                            library.blacktracer2.To = Vector2.new(toPos.X + env.Tracer.Thickness, toPos.Y)
                            
                            library.tracer.Visible = true
                            library.blacktracer.Visible = env.Tracer.Outline
                            library.blacktracer2.Visible = env.Tracer.Outline
                            
                            library.tracer.Color = GetTeamColor(plr)
                        else
                            library.tracer.Visible = false
                            library.blacktracer.Visible = false
                            library.blacktracer2.Visible = false
                        end
                    else
                        library.tracer.Visible = false
                        library.blacktracer.Visible = false
                        library.blacktracer2.Visible = false
                    end
                end)
            end)
        end

        characterConnection = plr.CharacterAdded:Connect(UpdateESP)
        UpdateESP()
        TracerConnections[plr.Name] = {renderConnection, characterConnection}
    end
    coroutine.wrap(Updater)()
end

local function InitTracer()
    for _, v in pairs(Players:GetPlayers()) do
        if v.Name ~= LocalPlayer.Name then
            coroutine.wrap(TracerESP)(v)
        end
    end

    Players.PlayerAdded:Connect(function(newplr)
        if newplr.Name ~= LocalPlayer.Name then
            coroutine.wrap(TracerESP)(newplr)
        end
    end)

    Players.PlayerRemoving:Connect(function(plr)
        if TracerConnections[plr.Name] then
            for _, conn in pairs(TracerConnections[plr.Name]) do
                conn:Disconnect()
            end
            TracerConnections[plr.Name] = nil
        end
        if TracerLibraries[plr.Name] then
            TracerLibraries[plr.Name].tracer:Remove()
            TracerLibraries[plr.Name].blacktracer:Remove()
            TracerLibraries[plr.Name].blacktracer2:Remove()
            TracerLibraries[plr.Name] = nil
        end
    end)
end

Init2DBox()
Init3DBox()
InitArrows()
InitCornerBox()
InitChams()
InitSkeleton()
InitText()
InitTracer()

return env
